---
title: "10장: 클래스"
date: 2019-09-21 23:59:11
categories: cleancode
tag: 클린코드 개발
---

## 클래스 체계

클래스를 정의하는 표준 자바 관례에 다르면, 가장 먼저 변수 목록이 나온다. 정적 공개 상수(public static)가 있다면 맨처음에 나오고 다음으로 정적 비공개 변수가 나오고 이어서 비공개 인스턴스 변수가 나온다. 변수 목록 다음에는 공개함수가 나온다. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉, 추상화 단계가 순차적으로 내려간다.

### 캡슐화
변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없기 때문에 protected로 선언해 테스트 코드 접근을 허용하기도 한다. 

## 클래스는 작아야한다.
클래스를 만들때 첫번째 규칙은 크기다. 클래스 이름은 해당 클래스 책임을 기술해야 한다. 

### 단일 책임 원칙(Single Responsibility Principle, SRP)

클래스나 모듈은 책임, 즉 변경할 이유가 하나뿐이어야 한다는 원칙. 
```
public class Version{
	public int getMajorVersionNumber();
	public int getMinorVersionNumber();
	public int getBuildNumber();
}
```
규모가 어느 수준에 이르는 시스템은 논리가 많고 복잡하다. 이런 복잡성을 다루려면 체계적인 정리를 통해 쉽게 찾을 수 있게 하고 직접 영향이 미치는 컴포넌트를 쉽게 이해할 수 있다.

### 응집도(Cohesion)

클래스는 인스턴스 변수 수가 작아야 한다.  일반적으로 메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다. 응집도가 높은 클래스는 바람직하지 않다.

#### 응집도를 유지하면 작은 클래스 여럿이 나온다.

큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다. 리팩터링한 프로그램은 좀 더 길고 서술적인 변수이름을 사용하고 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용하고 공백을 추가하고 형식을 맞추기 때문에 코드의 길이가 늘어난다. 

## 변경하기 쉬운 클래스

대다수 시스템은 지속적인 변경이 가해진다. 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다. 구조적인 관점에서도 SRP를 위반하거나 일부에서만 사용하는 비공개 메서드는 코드를 개선할 수 있다. 공개 인터페이스를 각각 클래스에서 파생하는 클래스로 만든다면 함수 하나를 수정한다고 다른 함수가 망가질 위험도 사라지고 클래스가 서로 분리되었기 때문에 테스트 하기 쉽다.

### Open-Closed-Principle(OCP)
클래스는 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙. 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.

## 변경으로부터 격리
* 구체적인 클래스(concrete) : 상세한 구현(코드)을 포함
* 추상 클래스(abstract): 개념만 포함

상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 인터페이스와 추상클래스를 사용해 구현에 미치는 영향을 격리한다. 

### Dependency Inversion Principle (DIP)
클래스는 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙.

